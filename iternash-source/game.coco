from tqdm import tqdm

from iternash.util import Str
from iternash.agent import Agent


class Game:
    """Game class.

    Parameters:
    - _name_ is the name of the game.
    - _agents_ are agents to include in the environment.
    - _named_agents_ are names mapped to agents to give those names to
        in the environment.
    - _immediate_update_ controls whether new actions are added to the env
        immediately or only at the end of each step (defaults to True). When
        this is on the order of agents passed to Game should be the order in
        which they should be evaluated at each step.
    """
    final_step = False

    match def __init__(self, name is Str, *agents, immediate_update=True, **named_agents):
        self.name = name
        self.env = {"game": self}
        self.agents = []
        self.immediate_update = immediate_update
        self.i = 0
        self.add_agents(*agents, **named_agents)

    def add_agents(self, *agents, **named_agents):
        """Add the given agents/variables to the game."""
        for a in agents :: named_agents.items():
            match (name, actor) in a:
                if not callable(actor):
                    assert isinstance(name, Str), f"not isinstance({name}, Str)"
                    self.env[name] = actor
                    continue
                elif isinstance(actor, Agent):
                    a = actor.clone(name=name)
                else:
                    a = Agent(name, actor)
            assert isinstance(a, Agent), f"not isinstance({a}, Agent)"
            if a.has_default() and a.name is not None:
                self.env[a.name] = a.default
            self.agents.append(a)

    def attach(self, agent, period, name=None):
        """Add an agent to be called at interval _period_."""
        if isinstance(agent, Agent):
            agent = agent.clone(name=name, period=period)
        else:
            agent = Agent(name, agent, period=period)
        self.agents.append(agent)

    def step(self, final=False):
        """Perform one full step of action selection."""
        if final:
            self.final_step = True
            try:
                return self.step()
            finally:
                self.final_step = False
        else:
            updating_env = self.env if self.immediate_update else {}
            for a in self.agents:
                if self.i % a.period == 0:
                    action = a(self.env)
                    if a.name is not None:
                        updating_env[a.name] = action
            if not self.immediate_update:
                self.env.update(updating_env)
            self.i += 1
            return self.env

    def run(self, max_steps):
        """Iterate until equilibrium or _max_steps_ is reached."""
        for _ in tqdm(range(max_steps)):
            prev_env = self.env.copy()
            self.step()
            if self.env == prev_env:
                break
        return self.step(final=True)
